#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
  char a[][10]={
    "small"，
    "five!"
  };
  printf("%s\n",a[0]); // small
  printf("%s\n",a[1]); // five!
  printf("%p\n",a[0]); // 0x6dc0
  printf("%p\n",a[1]); // 0x6dca 地址相差10个字节
  printf("h :%p\n",&a[0][0]); // 0x6dc0
  printf("e :%p\n",&a[0][1]); // 0x6dc1 相差1个字节
  printf("a[0]+1:%s\n",a[0]+1); // a[0]+1:mall
  printf("a[1]+1:%s\n",a[1]+1); // a[1]+1:ive!
  return 0;
}
/* 二维数组a[][]，类似于,可以通过a[n]找到同一行的一维数组：
   a[n][   数组     ]
   ...
   ...
   a[3][   数组     ]
   a[2][   数组     ]
   a[1][   数组     ]
   a[0][   数组     ]
   二维数组a[][]，其中第二个[]必须有数字条件，表示每个数组大小；
   a[0]的地址和"small"的地址一样，或者说a[0]的地址和"small"中的's'地址是一样的，因为"small"和's'的地址是相同的
*/
/* 字符串（常量 or 本地字符串数组）本质也是数组，那么，如果是int类型的二维数组，代码如下 */
#include <stdio.h>
int main()
{
  int a[3][4] = {
    1,2,3,4,
    5,6,7,8,
    9,10,11,12 // 注意：这里只是排版看起来像二维数组，写成一行也是ok的~其实就是一行
  };
  printf("%d\n",a[2][2]); // 正常输出第三行第三列：11
  printf("a:%p\n",a[0]); // 0xe500
  printf("a[0][0]:%p\n",&a[0][0]); // 0xe500
  printf("a:%p\n",a[1]); // 0xe510 与a[0]相差4*sizeof(int) = 16字节
  printf("a[1][0]:%p\n",&a[1][0]); // 0xe510
  printf("a:%p\n",a[2]); // 0xe520 与a[1]相差16字节，与a[0]相差32字节
  printf("a[2][0]:%p\n",&a[2][0]); // 0xe520
  printf("%d\n",*(a[0]+1)); // 2 这里a[0]看成是一个指针，存储行数组的地址，a[0]+1表示地址向后移动一个单位，最后通过*调用值
  printf("%d\n",(a[0]+1)[0]); // 2 这里的[0]其实和*作用类似
  printf("%d\n",(a[0]+1)[1]); // 3 
  int *p=a[0]; // 声明指针p，指向a，从这个正确的语句可以看出来，a[0]确实是一个地址
  printf("p:%p\n",p); // 0xe500，与a[0]相同
  printf("p+1:%p\n",p+1); // 0xe504，说明p的地址与a[0][0]相同，且步长也与a[0][0]相同，为一个单位，即1个int的长度 = 4字节
  printf("p+1:%d\n",(p+1)[0]); // 2,这里也可以使用*(p+1)
  return 0;
}

/* 所谓指针数组 */
